
## 页面置换算法

* LRU(最近最久未使用算法):


* 什么是内核态,什么是用户态:
    -   需要先了解特权级的概念:
        -   `WIP`
    -   用户态: 当一个进程在执行`用户自己的代码`的时候,处于用户运行态,此时特权最低,为3级
    -   当需要调用内核代码的时候就会进入内核态,特权级为0级
    -   用户态切换到内核态的方式:
        -   系统调用
        -   异常
        -   外围设备的中断
* linux有哪些进程状态:
    -   `运行状态`: 表示正在被cpu执行,处于运行状态,
    -   `可中断睡眠状态`: 处于这个状态的线程,不会被cpu调度,而是当得到释放的资源,或者进程通知的时候才会执行
    -   `不可中断睡眠状态`: 只有被wakeup调度才会执行
    -   `暂停状态`: 当收到SIGSTOP,SIGSTP,SIGTIIN,当收到SIGCONT会继续执行
    -   `僵死状态`: 进程已经停止运行,但是父进程没有询问其状态的时候
> 当一个`进程的运行时间片`用完，系统就会使用调度程序强制切换到其它的进程去执行。另外，如果进程在内核态执行时需要等待系统的某个资源，此时该进程就会调用sleep_on()或sleep_on_interruptible()自愿地放弃CPU的使用权，而让调度程序去执行其它进程。进程则进入睡眠状态（TASK_UNINTERRUPTIBLE或TASK_INTERRUPTIBLE）。
只有当进程从“内核运行态”转移到“睡眠状态”时，内核才会进行进程切换操作。在内核态下运行的进程不能被其它进程抢占，而且一个进程不能改变另一个进程的状态。为了避免进程切换时造成内核数据错误，内核在执行临界区代码时会禁止一切中断。
>> 总结:
1 . `cpu时间片用完`,会切换到其他进程 
2 .  `内核态等待资源时`,会进入可中断睡眠状态,自愿放弃
>>> 等待状态进入的条件:
1 . 进程cpu时间片用完
2 . 内核态进程需要等待系统的某个资源

* 线程的状态有哪些:
    -   `新建`NEW: 新建一个线程对象
    -   `可运行`RUNNABLE: 表示正在等待获取cpu时间片
    -   `运行`RUNNING: 表示此线程获取到了cpu使用权
    -   `阻塞`BLOCKED: 因某种原因放弃了cpu时间片,进入阻塞状态
    -   `死亡`DEAD: 
    - ![](https://img-blog.csdnimg.cn/20190218134918592.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyX0pva2Vy,size_16,color_FFFFFF,t_70)
    
* 进程和线程的区别:
    -   进程是`资源分配`的基本单位,而线程是`进程运行的`的最小单位
    -   进程拥有`独立的地址空间`,每次新建一个进程,程序都会为其分配数据表维护代码段数据段之类的,而`线程共享进程的数据`,一个进程至少有一个线程
    -   进程间的通信通过:
        -   `共享内存+信号量`: 共享内存是最快的一种方式,但是因为是共享所以非线程安全,因而通过信号量联合使用
        -   `管道`: 用于父子进程之间的通信
        -   `消息队列`: 是一个链表,有进程的标识符
        -   `FIFO`: 也成为命名管道, 是`文件类型`,可以通信与任何进程
        > -   总结:
            -   管道: 通信快,但是只能共享内存
            -   FIFO: 适用于任何进程,但是通信慢
            -   消息队列: 受到系统限制,并且需要考虑到上个消息是否已经被消费
            -   共享内存: 速度最快,但是要同步
* fork的原理(`待补`):
    -   `写时复制`技术: 既只有当父进程空间的数据段发生了变化,才会将父进程的内容复制一份给子进程,fork之后两个进程用的是同一个内存空间,只有在变化后,变化的那部分指向的是新的空间