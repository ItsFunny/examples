# JVM分析

* 具体的代码都会有空的时候再重新整理

---

#### JVM内存模型

* 堆 : 存放新创建的对象

* 虚拟机栈: 存放本地方法,每个方法都是一个`栈帧`,每个栈帧存放着`局部变量表,动态链接,操作数栈等信息`

* 本地方法栈: 同上,但是存放的是本地native方法

* 程序计数器: 代表程序执行到哪了

* 方法区: 存放类信息,及时编译后的代码, 运行时常量池也在这

#### 对象创建过程
* `对象创建过程`:[参考链接](https://blog.csdn.net/ma_chen_qq/article/details/81023957)
    -   首先当new一个对象的时候,会通过类的信息查看是否已经被加载到了内存中,如果未加载到内存,则会触发类加载机制:
        -   加载: 通过类的限定符,将类以二进制流的方式加载到jvm内存中,生成Class对象
        -   验证: 验证字节码是否符合jvm要求
        -   准备: `为类的静态变量分配存储空间`,然后初始化复制0(final除外,并且boolean 的初始值为false)
        -   连接: 符号引用替换为直接引用
        -   初始化: 执行构造函数等方法  
    -   之后则是在堆中创建对象(申明空间),这里的话不同的gc算法有不同的空间空间策略,内存分配完毕之后,对mark word头部信息设定一些初始化,如当前持有的线程id,分代年龄,hash码等信息,然后初始化即可
    -   划分空间时的问题:(因为堆是线程共享的)
        -   cas失败重试机制
    

##  JVM中对象在内存中的形态:
-   对象在内存中的布局可以分为三块:
    -   `对象头(header)`:包括两部分信息
        -   mark world: 用于存储对象运行时的数据,如`hashCode`,`GC年龄`,`锁状态标志`,`线程持有的锁`,`偏向的线程id`,`偏向时间戳等`
        -   kclass:kclass类型指针,既对象指向它的类元数据的指针,虚拟机通过这个判断是哪个对象的实例
        -   数组长度(可选):如果对象是一个数组,记录数组的长度
    -   `实例数据(instance data)`:是对象存储的真正有效数据,既class对象中定义的各种类型的字段内容,包括父类的数据
    -   `对齐填充(padding)`:仅仅起着占位符的作用,作用为调整为8字节的整数(既对象大小必须为8的整数倍),对齐填充就是补齐的作用
   

#   可达性算法有两种:
-   引用计数法:每个对象都有一个引用计数器,每当有个对象引用他,计数器就会+1,回收会回收计数器为0的对象,`但是这种方法无法解决循环引用的问题`,也就是说回造成内存泄漏
-   可达性算法: 从GC Roots根节出发,能连通的对象都是存活着的对象,对于无法到达的对象就认为是可以回收的对象
#   GC算法  
-   `标记清除算法`: 分为2个阶段,标记-清除阶段,清除的时候会统一回收对象
    -   不足: 效率低下,空间问题:存在大量不连续的内存碎片
-   `复制算法`: 将内存分为2块,每次只使用其中一块,通过可达性分析标记出回收的对象,然后直接回收
    -   不足: 会存在大量的内存碎片,无法分配大对象,可能能会促使full gc
-   `标记整理算法`: 与复制算法类似,每次都只使用其中1块,但是不同点在于,会整理回收的对象,使得回收的对象聚集在一起,`也就没有大量内存碎片的说法`
    -   不足: 
-   `分代算法`: 既新生代因为总是有大批量的对象死去,所以采用复制算法,而老年代采用标记-清除或者标记-整理算法

# GC收集器

-   `Serial收集器`:串行收集器是最古老的一种,也是最稳定的,新生代复制算法,而老年代标记-整理算法 -XX:+UseSerialGC
-   `ParNew收集器`:串行收集器的多线程版本,新生代并行,老年代串行,新生代采用复制,而老年代采用标记-整理
-   `Parallel收集器`: 类似于ParNew收集器,但是Parallel更加关注于吞吐量,会根据系统的运行情况动态调整参数(从而改变stw时间) -XX:+UseParallelGC
-   `Parallel Old收集器`: 是Parallel收集器的老版本-XX:+UseParallelOldGC
-   `CMS收集器`:宗旨是stw时间最短,整个过程可以认为有4个流程:
    -   `初始标记`:会触发stw,仅仅只是标记gc roots能直接关联到的对象
    -   `并发标记`:字面理解即可
    -   `重新标记`:会stw,类似于双重检测机制
    -   `并发清除`:多线程回收
    -   停顿时间:并发标记,并发清楚>重新标记>初始标记,`优点:并发收集,低停顿,缺点在于新生代采用的是复制算法,有大量内存碎片,并且并发降低吞吐量`
-   `G1收集器`:为了替换cms而存在,g1的内存模型有region(内存分区的概念),回收的时候会以分区为基础进行回收,宗旨是`尽可能收集多的垃圾,因而不会在内存不足时才进行`
    -   `标记阶段`: 初始化标记,会触发minor gc
    -   `内存分区扫描`
    -   `并发标记`: 对整个堆进行扫描,如果发现这个region都是垃圾,则会直接进行回收,非阻塞
    -   `重新标记`: stw
    -   `多线程清除失活对象`
#  命令行相关:

-   设定最大堆的大小: -Xmx256m
-   设定初始堆的大小: -Xms256m
-   设定每个线程栈的大小: -Xss128k
-   设定年轻代大小: -XX:NewSize=n
-   设定年轻代和年老代的比值:-XX:NewRatio=4 既年轻代:年老代=1:4(年轻代占1/5)
-   年轻代中eden与survivor的比值:-XX:SurvivorRatio=4 既eden:from-survivor:to-survivor=4:1:1 (survivor占1/6)
-   升级到老年代的最大年龄:-XX:MaxTenuringThreshold=13 当年龄超过13岁则会进入老年代


#   触发minor gc的条件:
 
-   当新生代空间不足的时候会触发minor gc
    
#   触发full gc的条件

-   当新生代空间不足,需要老年代担保,但是老年代无法有足够担保时会触发full gc
-   当新生代对象移到老年代,而老年代没有充足空间的时候
-   大对象直接进入老年代,老年代空间不足
-   新生代某个年龄的次数>=一半,则>=这个年龄的对象会进入老年代,老年代空间不足时
-   当方法区内存不足时(也称为永久代)(存放类信息,常量,静态变量,及时编译后的代码等)



# JVM 优化

### 即时编译器 JIT

* 什么是即时编译器: 当JVM发现某个方法或者某个代码块运行非常频繁(`热点代码`)的时候,就会将其编译为本地平台相关的机器码,完成这个任务的编译器称为`即时编译器`
* 热点代码: 
    -   被多次调用的方法
    -   被多次调用的循环体
* 判断是否是热点代码的方式: 
    -   基于采样的热点探测: 有一个线程周期性的检查各个线程的栈顶,若某个方法经常出现在
    -   基于计数器的热点探测: 为每个方法都设置了一个计数器,当达到阈值就认为是热点方法


### 逃逸分析: 
* 基本行为: 分析对象的作用域:当一个对象定义之后,可能被外部所引用,也可能继续被其他方法所调用从而延长了生命周期
    -   方法逃逸: 指的是对象被其他方法所调用
    -   线程逃逸: 赋值给类变量,从而其他线程也可以访问
* 如果确定对象的不会逃逸,JVM会做如下优化:
    -  `栈上分配`: 对象大多都申请在堆中,但是堆中GC的时候复杂,如果确定对象不会发生逃逸,则可以直接分配在栈上,那么
    当方法调用结束之后,这个对象也可直接回收了 
        -   **额外**: 在栈上分配的变量,很大的概率会被虚拟机分配至物理机器的高速寄存器上
    -   `同步消除`: 线程的同步耗费性能,如果逃逸分析其不会逃逸出该线程,则会发生优化:该变量的读写不会有竞争,会取消同步措施
    -   `标量替换`: 指的是拆分对象,在Java中基本数据类型以及reference类型都是最小的不可拆分对象,称为`标量`,相对的称为`聚合量`,如对象,
    当逃逸分析发现其不会不会被外部访问的时候,JVM会为其拆解:`不会创建这个对象,而是改为由若干个相关的成员变量代替,这些成员变量存储在栈上`