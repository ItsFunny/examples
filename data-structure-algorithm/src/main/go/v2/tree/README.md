# 二叉树

## 遍历
- 前序遍历: 先访问根节点,再前序遍历左子树,再前序遍历右子树,既**根左右**
    -   非递归先序遍历
        -   值在遍历左孩子的时候就入队列了
- 中序遍历: 先中序遍历左子树,再访问根节点,再中序遍历右子树,既**根左右**
    -   递归中序遍历
        -   注意点:
            -   与先序不同的是,值是在出栈的时候赋值的
- 后序遍历: 先后序遍历左子树,再后序遍历右子树,再访问根节点,既**左右根**
    -   非递归后序遍历
        -   注意点:
            -   根节点在右节点弹出之后才能弹出
- 注意:
    - 以根访问顺序决定是什么遍历
    - 左子树都是优先于右子树
    - 非递归遍历树,在入栈的时候,都是`一路向左`,数据除了`先序遍历`都是在出栈的时候获取元素

---

- DFS 遍历: 深度搜索
    -   通过栈的形式:
        -   DFS需要结合栈
        -   注意: 入栈的时候,是先右孩子入栈,再左孩子入栈
    -   通过递归的形式: 
        -   通过分治法:
            -   
- BFS遍历: 层次遍历
    -   通过队列的形式
        -   注意: 如队的时候,是需要先将左孩子入队,因为是层次遍历,层次遍历是从左到右,`所以先左孩子入队,再右孩子`      
-   分治法的应用
    -   先分别处理局部,再合并结果
    -   适用场景:
        -   快速排序
        -   堆并排序
        -   二叉树相关问题
    -   模板:
        -   递归返回条件
        -   分段处理
        -   合并结果
        -   `既需要递归`
        -   
        ```
        func divide(data *Data)Result{
            if (data==nil){
                // doSomething & returnData
            }   
            // 分
            Result left=divide(data.left)
            Result right=divide(data.right)
            
            // 合
            Result result= 合并本来的数据和lfet+right
            return result
        }
        ```
---
- 注意:
    - 关于DFS和BFS 借助数据结构的时候
        -   DFS: 栈 : (战地)
        -   BFS: 队列:
        -   先左孩子还是右孩子
            -   记忆: 层次遍历BFS: 从左到右,所以先左孩子再右孩子,DFS相反先右孩子再左孩子  