
## 更新日志


- 2019-01-17
	* 23:42
		-	修改了CompleteTree的讲解,干脆一直将节点认为是从0开始,而非从1,开始,也就是说左孩子的节点下标为:2*index+1,右孩子:2*index+2,而临界值变为了arr.length-1
		-	添加了堆排序已经部分讲解,也添加了TODO(复杂度之类的,还有非递归实现,以及测试用例需要补全)

- 2019-01-18
    * 09:32
        -   添加了堆排序中非递归建堆的部分(简单来说就是通过动态改值)
        -   一些TODO也添加了(复杂度解析之类的)
        
- 2019-01-20
    *   10:09
        -   今天的话添加了普通版的快速排序,三值版的可能会晚上添加,昨天的话将海量数据的测试数据
        预加载好了(总共500w)
    *   11:42
        -   添加了map遍历的4种方式(通过key遍历value,直接遍历value,通过entrySet.iterator遍历所有的key和value,通过entrySet直接遍历所有的key和value)
    *   15:19
        添加了ArrayList的简单实现,参考价值不大
    *   16:08
        -   添加了通过2个栈实现一个队列,简单点说就是2个栈,恒定往一个栈A中传递数据,pop的时候栈B将push的栈A中的数据全部push到这个栈B中,
        然后栈B出队,这样先进后出的值变成了先进先出(a->b->c 入栈A,出栈:c->b->a到栈B中,a就变成了相当于后进的了)
    *   16:55
        -   添加了原生栈的简单实现,与list相同,参考意义不大
    *   18:04
        -   添加了通过2个队列实现一个栈的功能,简单点说就是2个队列,2个队列中保持着一个为空,另一个非空

-   01-21
    *   12:20
        -   添加了单链表的实现(只有root节点的链表),注意点的话就是删除的时候要先获取他的前驱节点,指向这个节点的后继节点
    *   14:28
        -   添加了单向循环链表(有tail和head指针,tail的下一级指向头指针)的实现,在循环链表中next是不可能为空的,在删除操作
        时候需要判断这个节点是否是尾部节点,要捕获前驱节点(意味着需要遍历),然后重新移动尾部节点和下一个节点的指向
    * 18:19
        -   添加了hash冲突问题解决方案中的开放地址之线性探测法,remove未写,测试用例也未写
 
- 01-24
    *   23:51
        -   添加了时间轮算法的简单实现V1,但是测试的时候ide总是提示 !!! JUnit version 3.8 or later expected:
        啥鬼玩意,头疼,明天看会不会有空,有空的话解决,然后完善下方案,bug有点多的
        
- 01-26
    *   15:36
        -   添加了非递归遍历二叉树的先序和中序版本
    *   21:00
        -   添加了非递归遍历二叉树后序遍历
        -   添加了非递归遍历二叉树后序遍历

- 01-27
    *   10:53
        -   添加了go版的线程池的简易实现,二级队列保存每个worker的工作池来实现

- 01-27
    *   14:51
        -   添加了jdk动态代理的形式
    
    *   17:00
        -   添加了基于cglib动态代理的形式

- 01-28
    *   15:42
        -   添加了二叉查找树的插入和删除操作,在src/main/go/structre/tree/binary_search_tree下,并且已经补全了测试用例,null的默认跳过

- 01-29
    *   15:17
        -   添加了解决hash冲突的另外一种方法:链地址法,其实就是实现一个HashMap,实现HashMap的难点在于红黑树部分,以及扩容部分,未实现
    *   16:36
        -   添加了hashSet,其实也是Map,底层是通过map实现的
- 01-30
    *   11:21
        -   添加了双向循环链表的实现
        -   添加了测试用例**测试用例不会测试性能,只是为了证明思路是正确的**
    *   13:59
        -   添加了通过快慢指针判断链表是否有环的方法
        -   添加了获取回环的节点的方法`(注意一点就是快慢指针同步率的时候,快慢节点的起始位置是同一位置,否则若初始化的时候快节点就快了一步,则重新同步的时候快节点也需要先快一步)`   
- 01-31
    * 13:01
        -   添加了高速缓存的实现,可添加到个人库中,但是底层的数据结构需要优化,不就会换位RingBuffer无锁的形式,并且现在添加的是基于软引用的,也可延伸为弱引用

- 02-08
    * 11:26
        -   添加了producer-consumer模型

- 02-17
    * 22:15
        -   添加了简单版的lru,当然是模仿LinkedHashMap的(不过其底层是红黑树,而我则直接链表了)